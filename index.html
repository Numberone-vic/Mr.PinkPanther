<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>AKA 1908 — Maze of Excellence</title>
<style>
  :root{
    --pink: #FF69B4;
    --pink-deep: #FF1493;
    --green: #009B48;
    --gold: #FFD700;
    --bg-dark: #06120d;
    --card: #fff;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  html,body{height:100%;font-family:Inter,Arial,sans-serif;background:linear-gradient(180deg,#06120d,#07261b);color:white}
  #menuScreen, #levelCompleteScreen, #gameCompleteScreen { display:none; align-items:center; justify-content:center; min-height:100vh; padding:24px; }
  .menuBg { background: linear-gradient(135deg, var(--pink), var(--green)); }
  .levelBg { background: linear-gradient(135deg, var(--green), var(--pink)); }
  .completeBg { background: linear-gradient(135deg, var(--pink-deep), #60b07f); }

  .card {
    background: var(--card);
    color: #111;
    padding: 28px;
    border-radius: 12px;
    box-shadow: 0 12px 40px rgba(0,0,0,0.45);
    max-width: 880px;
    width: calc(100% - 48px);
    text-align: center;
  }
  h1{font-size:2.6rem;margin-bottom:12px}
  h2{font-size:1.6rem;margin-bottom:8px}
  .pink { color: var(--pink); }
  .green { color: var(--green); }

  #gameContainer { display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-height:100vh; padding:28px; gap:12px; }
  #gameCanvas { border: 6px solid var(--pink); border-radius:10px; background: #003d26; display:none; touch-action:none; }
  #hud { display:flex; gap:12px; align-items:center; width:100%; max-width:900px; justify-content:space-between; color:white; }
  .hudLeft { display:flex; gap:12px; align-items:center; }
  .hudStat { background: rgba(255,255,255,0.06); padding:8px 12px; border-radius:8px; font-weight:600; }
  #menuBtn { display:none; padding:10px 20px; border-radius:8px; border:none; cursor:pointer; background:var(--green); color:white; font-weight:700; }

  #controls { display:none; position:fixed; right:16px; bottom:18px; grid-template-columns: repeat(3, 64px); gap:8px; z-index:40; }
  .controlBtn { width:64px; height:64px; border-radius:12px; border:2px solid rgba(255,255,255,0.08); background: rgba(255,255,255,0.04); color:white; font-size:24px; font-weight:800; -webkit-tap-highlight-color: transparent; }
  .controlBtn:active { transform:scale(.96); box-shadow:0 8px 16px rgba(0,0,0,0.3) inset; }
  .controlBtn.glow { box-shadow: 0 0 18px rgba(255,105,180,0.25), 0 4px 10px rgba(0,0,0,0.3); backdrop-filter: blur(2px); }

  .levelBanner { position:fixed; left:50%; top:10%; transform:translateX(-50%); background:linear-gradient(90deg,var(--pink),var(--green)); color:white; padding:12px 22px; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,0.5); font-weight:800; z-index:80; opacity:0; pointer-events:none; }

  @media (max-width:720px){
    .controlBtn { width:56px;height:56px;border-radius:10px;font-size:20px; }
    #gameCanvas { width:95vw; height:auto; max-width:720px; display:block; }
    #menuBtn { display:block; }
  }
  @media (min-width:721px){
    #gameCanvas { width:900px; height:500px; display:block; }
    #menuBtn { display:block; }
  }

  .pillarsBox { background: linear-gradient(180deg, rgba(255,105,180,0.06), rgba(0,155,72,0.03)); padding:12px; border-radius:8px; margin:12px 0; text-align:left; color:#111; }
  .btn { padding:12px 22px; border-radius:8px; border:none; font-weight:700; cursor:pointer; }
  .pinkBtn { background:var(--pink); color:white; }
  .greenBtn { background:var(--green); color:white; }
  .muted { color:#666; font-size:0.95rem; }

    <div id="controls" aria-hidden="false" style="display:grid; grid-template-columns: repeat(3,64px); gap:8px;">
      <div></div>
      <button class="controlBtn" id="upBtn">↑</button>
      <div></div>
      <button class="controlBtn" id="leftBtn">←</button>
      <div></div>
      <button class="controlBtn" id="rightBtn">→</button>
      <div></div>
      <button class="controlBtn" id="downBtn">↓</button>
      <div></div>
    </div>
  </div>

  <div id="levelBanner" class="levelBanner" aria-hidden="true"></div>

<script>
/* -------------------------
  AKA 1908 — Maze of Excellence
  Single-file remastered build
------------------------- */

const PILLARS = [
  { name: "Scholarship", quote: "The pursuit of knowledge begins here.", theme: "green" },
  { name: "Sisterhood", quote: "Together, we rise.", theme: "pink" },
  { name: "Leadership", quote: "Lead with purpose and grace.", theme: "green" },
  { name: "Social Justice", quote: "Stand for what is right.", theme: "pink" },
  { name: "Service to All Mankind", quote: "Service crowns all.", theme: "gradient" }
];

/* ---------------- Levels (adjusted for solvability) ---------------- */
const LEVELS = [
  // 1 Scholarship (open aisles)
  [
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"X S    X      E          E       X   X",
"X XXXX X XXXX XXXXX   XXXX XXXX X X X",
"X X             X      X    X     X",
"X XXXX X XXXX X XXXXX XXXX X    XXX X X",
"X    E X    E X           X     C  ",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  ],

  // 2 Sisterhood (loops and bridges)
  [
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"X S  X   E    XXXX   E      XXXX    X",
"X    X XXXX  X    X  XXXX  X    X  X",
"X E  X X  X  X E  X  X  X  X E  X  X",
"X    X X  X  XXXX X  X  X  X    X  X",
"X XXXX X  X      X      X  X    C  X",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  ],

  // 3 Leadership (central path, forks) — open gap near crown row
  [
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"X S      XXXX       E       XXXX    X",
"X XXXX   X  X  XXXXXX  X  X  X  X   X",
"X X  X   X  X    E    X  X  X  X   X",
"X X  X   X  X  XXXXXX X  X  X  X   X",
"X    X      E       X      X       X",
"X    XXXX      X     XXXX       C  X",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  ],

  // 4 Social Justice (symmetry / balance) — corridor added
  [
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"X S   XXXXXXXXX   P  X  P  XXXXXXXXX X",
"X     X       X      X      X       X",
"X  E  X   E   X  E   X   E  X   E   X",
"X     X       X      X      X       X",
"X XXXXX XXXXX XX   XXXXXXXX XXXXXXXXX",
"X        P             E         C  X",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  ],

  // 5 Service to All Mankind (final, larger) — opened access near crown and E’s
  [
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
"X S     X   X   X     X     X   X   X",
"X   X   X E X E X  E  X  E  X E X E X",
"X   X   X   X   X     X     X   X   X",
"X   X   XXXXXXX   XXXXXXX  XXXXX   X ",
"X   X               E            X  X",
"X   XXXXX  XXXX  XXXX  XXXX  XXXX   X",
"X        X      C      X     E      X",
"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
  ]
];

/* ---------------- Canvas, state & setup ---------------- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let game = {
  TILE: 25,
  WIDTH: 900,
  HEIGHT: 500,
  player: { x: 0, y: 0, size: 16 },
  walls: [],
  symbols: [],
// audio
let audioOn = true;
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;
function chime(freq = 880, time = 0.14, type='sine') {
  if(!audioOn || !audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.value = freq;
  g.gain.value = 0.12;
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time);
  o.stop(audioCtx.currentTime + time + 0.02);
}

/* ---------------- Responsive sizing ---------------- */
function resizeCanvas() {
  const level = LEVELS[game.currentLevel];
  const cols = level[0].length;
  const rows = level.length;

  const maxW = Math.min(window.innerWidth - 40, 980);
  const maxH = Math.min(window.innerHeight * 0.68, 720);
  const tile = Math.max(12, Math.floor(Math.min(maxW / cols, maxH / rows)));
  const cw = cols * tile;
  const ch = rows * tile;

  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.width = Math.max(300, cw * (window.devicePixelRatio || 1));
  canvas.height = Math.max(200, ch * (window.devicePixelRatio || 1));
  ctx.setTransform(window.devicePixelRatio || 1, 0, 0, window.devicePixelRatio || 1, 0, 0);

  game.TILE = tile;
  game.WIDTH = cw;
  game.HEIGHT = ch;
}
window.addEventListener('resize', resizeCanvas);

/* ---------------- Level loader ---------------- */
function loadLevel(levelIndex) {
  levelIndex = Math.max(0, Math.min(levelIndex, LEVELS.length - 1));
  game.currentLevel = levelIndex;
  game.walls = [];
  game.symbols = [];
  game.crown = null;
  game.collected = 0;
  game.particles = [];

  const raw = LEVELS[levelIndex];
  for(let y=0;y<raw.length;y++){
    const row = raw[y];
    for(let x=0;x<row.length;x++){
      const ch = row[x];
      const px = x * game.TILE;
      const py = y * game.TILE;
      if(ch === 'X') {
        game.walls.push({ x: px, y: py, w: game.TILE, h: game.TILE });
      } else if(ch === 'S') {
        game.player.x = px + (game.TILE - game.player.size)/2;
        game.player.y = py + (game.TILE - game.player.size)/2;
      } else if(ch === 'E' || ch === 'P') {
        game.symbols.push({ x: px + game.TILE/2, y: py + game.TILE/2, r: Math.max(5, game.TILE * 0.18), pulse: Math.random()*Math.PI*2 });
      } else if(ch === 'C') {
        game.crown = { x: px + 6, y: py + 6, w: game.TILE - 12, h: game.TILE - 12 };
      }
    }
  }
  game.totalSymbols = game.symbols.length;
  pearlsCount.textContent = `Symbols: ${game.collected} / ${game.totalSymbols}`;
  pillarName.textContent = `Pillar: ${PILLARS[game.currentLevel].name}`;

  resizeCanvas();
}

/* ---------------- Collision -------------- */
function aabb(ax,ay,aw,ah,bx,by,bw,bh) {
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}
function checkWallCollision(x,y,w,h){
  for(const wall of game.walls){
    if(aabb(x,y,w,h,wall.x,wall.y,wall.w,wall.h)) return true;
  }
  return false;
}

/* ---------------- Particles ---------------- */
function spawnParticles(x,y,count=14,color='white'){
  for(let i=0;i<count;i++){
    const ang = Math.random()*Math.PI*2;
    const speed = Math.random()*2.6 + 0.6;
    game.particles.push({ x, y, vx: Math.cos(ang)*speed, vy: Math.sin(ang)*speed, life: 30 + Math.random()*30, size: Math.random()*2 + 1, color});
  }
}

/* ---------------- Drawing symbols ---------------- */
function drawSymbol(ctx, sym, levelIndex) {
  const x = sym.x, y = sym.y, r = sym.r;
  ctx.save();
  ctx.translate(x,y);
  const t = levelIndex;
  if(t === 0) { // Scholarship -> open book
    ctx.fillStyle = 'rgba(0,220,120,0.95)';
    ctx.beginPath();
    ctx.moveTo(-r, -r/2);
    ctx.quadraticCurveTo(-r/2, -r, 0, -r/1.5);
    ctx.quadraticCurveTo(r/2, -r, r, -r/2);
    ctx.lineTo(r, r/1.8);
    ctx.quadraticCurveTo(r/2, r/1.2, 0, r/1.4);
    ctx.quadraticCurveTo(-r/2, r/1.2, -r, r/1.8);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.fillRect(-r*0.9, -r*0.25, r*1.8, 2);
  } else if(t === 1) { // Sisterhood -> linked hearts
    ctx.fillStyle = 'rgba(255,105,180,0.95)';
    ctx.beginPath();
    ctx.moveTo(-r/2,0);
    ctx.arc(-r/2, -r/6, r/3, Math.PI, 0);
    ctx.arc(r/2, -r/6, r/3, Math.PI, 0);
    ctx.bezierCurveTo(r, r/2, 0, r*0.95, 0, r*0.6);
    ctx.bezierCurveTo(0, r*0.95, -r, r/2, -r/2, 0);
    ctx.fill();
  } else if(t === 2) { // Leadership -> crown
    ctx.fillStyle = 'gold';
    ctx.beginPath();
    ctx.moveTo(-r, r/2);
    ctx.lineTo(-r/2, -r/2);
    ctx.lineTo(0, r/4);
    ctx.lineTo(r/2, -r/2);
    ctx.lineTo(r, r/2);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle='#c79b00'; ctx.fillRect(-r*0.6, r/3, r*1.2, 3);
  } else if(t === 3) { // Social Justice -> scales
    ctx.fillStyle = 'rgba(200,100,200,0.95)';
    ctx.beginPath();
    ctx.rect(-r/8, -r*0.9, r/4, r*1.6);
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(-r*0.6, -r*0.15);
    ctx.lineTo(-r*0.12, -r*0.15);
    ctx.lineTo(-r*0.36, r*0.35);
    ctx.lineTo(-r*0.84, r*0.15);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(r*0.6, -r*0.15);
    ctx.lineTo(r*0.12, -r*0.15);
    ctx.lineTo(r*0.36, r*0.35);
    ctx.lineTo(r*0.84, r*0.15);
    ctx.closePath();
    ctx.fill();
  } else { // Service -> gradient heart
    const g = ctx.createRadialGradient(0,0,r*0.2, 0,0,r);
    g.addColorStop(0, 'rgba(255,105,180,0.95)');
    g.addColorStop(1, 'rgba(0,155,72,0.95)');
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.moveTo(0, r*0.6);
    ctx.bezierCurveTo(-r, r*0.1, -r*0.6, -r*0.6, 0, -r*0.2);
    ctx.bezierCurveTo(r*0.6, -r*0.6, r, r*0.1, 0, r*0.6);
    ctx.fill();
  }
  ctx.restore();
}

/* ---------------- Draw whole scene ---------------- */
function draw() {
  const pIdx = game.currentLevel % PILLARS.length;
  const theme = PILLARS[pIdx].theme;
  let g = ctx.createLinearGradient(0,0,0,game.HEIGHT);
  if(theme === 'green') { g.addColorStop(0,'#003d26'); g.addColorStop(1,'#006a3a'); }
  else if(theme === 'pink') { g.addColorStop(0,'#2b002a'); g.addColorStop(1,'#5b003f'); }
  else { g.addColorStop(0,'#003d26'); g.addColorStop(1,'#5b003f'); }
  ctx.fillStyle = g; ctx.fillRect(0,0,game.WIDTH,game.HEIGHT);

  ctx.fillStyle = 'rgba(255,105,180,0.12)';
  for(const w of game.walls){
    roundRect(ctx, Math.round(w.x)+1, Math.round(w.y)+1, w.w-2, w.h-2, Math.max(3, game.TILE*0.12));
  }

  for(const sym of game.symbols){
    sym.pulse = (sym.pulse || 0) + 0.06;
    const pr = sym.r + Math.sin(sym.pulse) * Math.max(0.8, sym.r*0.18);
    ctx.save();
    ctx.globalAlpha = 1;
    ctx.shadowBlur = 12; ctx.shadowColor = 'rgba(255,255,255,0.25)';
    drawSymbol(ctx, {x: sym.x, y: sym.y, r: pr}, game.currentLevel);
    ctx.shadowBlur = 0; ctx.restore();
  }

  if(game.crown) {
    if(game.collected === game.totalSymbols) {
      ctx.save();
      ctx.shadowBlur = 16; ctx.shadowColor = 'rgba(255,215,0,0.9)';
      ctx.fillStyle = 'gold';
      roundRect(ctx, game.crown.x, game.crown.y, game.crown.w, game.crown.h, 6);
      ctx.restore();
    } else {
      ctx.fillStyle = 'rgba(255,215,0,0.5)';
      roundRect(ctx, game.crown.x, game.crown.y, game.crown.w, game.crown.h, 6);
    }
  }

  ctx.save();
  ctx.fillStyle = (PILLARS[game.currentLevel].theme === 'pink') ? 'rgba(255,105,180,0.95)' : 'rgba(0,200,115,0.95)';
  ctx.fillRect(game.player.x, game.player.y, game.player.size, game.player.size);
  ctx.strokeStyle = 'rgba(255,255,255,0.9)'; ctx.lineWidth = 2;
  ctx.strokeRect(game.player.x+0.5, game.player.y+0.5, game.player.size-1, game.player.size-1);
  ctx.restore();

  for(const p of game.particles){
    ctx.globalAlpha = Math.max(0, p.life / 60);
    ctx.fillStyle = p.color || 'white';
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  ctx.fillStyle = 'rgba(255,255,255,0.03)'; ctx.fillRect(8,8,260,36);
  ctx.fillStyle = 'white'; ctx.font = `${Math.max(12, Math.floor(game.TILE * 0.6))}px sans-serif`;
  ctx.fillText(`Symbols: ${game.collected}/${game.totalSymbols}`, 14, 32);
  ctx.fillText(`Pillar: ${PILLARS[game.currentLevel].name}`, game.WIDTH - 260, 32);
}

/* rounded rect helper */
function roundRect(ctx, x, y, w, h, r) {
  const radius = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+radius, y);
  ctx.arcTo(x+w, y, x+w, y+h, radius);
  ctx.arcTo(x+w, y+h, x, y+h, radius);
  ctx.arcTo(x, y+h, x, y, radius);
  ctx.arcTo(x, y, x+w, y, radius);
  ctx.closePath();
  ctx.fill();
}

/* ---------------- Update logic ---------------- */
function update() {
  let dx = 0, dy = 0;
  if(game.keys.up) dy -= 1;
  if(game.keys.down) dy += 1;
  if(game.keys.left) dx -= 1;
  if(game.keys.right) dx += 1;
  if(dx !== 0 || dy !== 0) {
    const len = Math.hypot(dx,dy);
    dx = dx/len * game.speed;
    dy = dy/len * game.speed;
  }

  const nx = game.player.x + dx;
  if(!checkWallCollision(nx, game.player.y, game.player.size, game.player.size)) game.player.x = nx;
  const ny = game.player.y + dy;
  if(!checkWallCollision(game.player.x, ny, game.player.size, game.player.size)) game.player.y = ny;

  for(let i = game.symbols.length - 1; i >= 0; i--) {
    const s = game.symbols[i];
    const cx = game.player.x + game.player.size/2;
    const cy = game.player.y + game.player.size/2;
    const dist = Math.hypot(cx - s.x, cy - s.y);
    if(dist < s.r + game.player.size/2 - 2) {
      spawnParticles(s.x, s.y, 18, 'rgba(255,255,255,0.95)');
      chime(880, 0.06, 'triangle');
      game.symbols.splice(i,1);
      game.collected++;
      pearlsCount.textContent = `Symbols: ${game.collected} / ${game.totalSymbols}`;
    }
  }

  if(game.crown && game.collected === game.totalSymbols) {
    if(aabb(game.player.x, game.player.y, game.player.size, game.player.size, game.crown.x, game.crown.y, game.crown.w, game.crown.h)) {
      onLevelComplete();
    }
  }

  for(let i = game.particles.length -1; i >=0; i--) {
    const p = game.particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.life -= 1; p.vx *= 0.99;
    if(p.life <= 0) game.particles.splice(i,1);
